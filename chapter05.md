# 실행 컨텍스트

- 함수가 실행되는 영역, 묶음
- 함수 코드를 실행하고 실행 결과를 저장한다
- 스펙상의 사양으로 엔진이 처리하는 과정이다
- 실행 콘텍스트 생성 시점은 실행 가능한 코드를 만난 시점이다
- 실행 가능한 코드 유형
  - 함수 코드
  - 글로벌 코드
  - eval 코드

- 코드 유형을 분리한 이유
  - 실행 콘텍스트에서 처리 방법과 실행 환경이 다르기 때문이다
  - 함수 코드 : 정적 렉시컬 환경
  - 글로벌 코드 : 글로벌 환경
  - eval 코드 : 동적 환경

## 실행 컨텍스트 상태 컴포넌트

- 실행 컨텍스트 상태를 위한 오브젝트 : 실행 콘텍스트 안에 생성

- 상태 컨포넌트 유형

  1. 렉시컬 환경 컴포넌트 LEC

     Lexical Environment Component

  2. 변수 환경 컴포넌트 VEC

     Variable Environment Component

  3. this 바인딩 컴포넌트 TBC

     This Binding Component

## 렉시컬 환경 컴포넌트 LEC

- 함수와 변수 식별자 해결을 위한 환경 설정
- 함수 초기화 단계에서 해석한
  - 함수와 변수를 {name: value} 형태로 저장
  - 이름으로 함수와 변수를 검색할 수 있게 됨

- 함수 밖의 함수와 변수 참조 환경 설정
  - 함수 밖의 함수와 변수를 사용할 수 있게 됨 

### 렉시컬 환경 컴포넌트 구성

- 렉시컬 환경 컴포넌트 생성
  - function, with, try-catch 에서 생성

- 컴포넌트 구성

  - 환경 레코드

    ER: Environment Record

  - 외부 렉시컬 환경 참조

    OLER: Outer Lexical Environment Reference

```json
실행 콘테스트(EC): {
    렉시컬 환경 컴포넌트(LEC) {
        환경 레코드(ER): {
            point: 100
        }
    },
	외부 렉시컬 환경 참조(OLER): {
        title: "책",
        getTitle: function(){}
    }
}
```

- 환경 레코드에 함수 안의 함수와 변수를 기록한다
- 외부 렉시컬 환경 참조에 function 오브젝트의 [[scope]]를 설정한다

### 외부 렉시컬 환경 설정

- 스코프와 실행중인 함수가 Context 형태이므로 스코프의 변수와 함수를 별도의 처리 없이 즉시 사용할 수 있다
- 실행 컨텍스트에서 함수 안밖의 함수, 변수를 사용할 수 있으므로 함수와 변수를 찾기 위해 실행 컨텍스트를 벗어 나지 않아도 된다 

### 변수 환경 컴포넌트

- 초기값 복원시 사용하기 위해 실행 콘텍스트 초기화 단계에서 렉시컬 환경 컨포넌트와 같게 설정한다
- 함수 코드가 실행되면 실행 결과를 렉시컬 환경 컴포넌트에 설정한다
- 초기값이 변하면 이를 유지하기 위함인다 

## 실행 컨텍스트 실행 과정

```js
var base = 200
function getPoint(bonus){
    var point = 100
    return point + base + bonus
}
console.log(getPoint(70)) // 370
```

1. getPoint 오브젝트의 [[Scope]]에 글로벌 오브젝트 설정한다

2. getPoint 함수를 호출한다

3. 자바스크립트 엔진은 실행 컨텍스트를 생성하고 실행 컨텍스트 안으로 이동한다

4. 컴포넌트를 생성하여 실행 컨텍스트에 첨부
   - 렉시컬 환경 컴포넌트
   - 변수 환경 컴포넌트
   - this 바인딩 컴포넌트

5. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부

   - 함수 안의 함수, 변수를 바인딩합니다

   ```json
   실행 콘테스트(EC): {
       렉시컬 환경 컴포넌트(LEC) = {
           환경 레코드(ER): {},
       },
   	변수 환경 컴포넌트(VEC): {},
   	this 바인딩 컴포넌트(TBC): {}
   }
   ```

6. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부하고 function 오브젝트의 [[Scope]]를 설정 

	```json
	실행 콘테스트(EC): {
    	렉시컬 환경 컴포넌트(LEC) = {
        	환경 레코드(ER): {},
			외부 렉시컬 환경 참조(OLER): {
        		base: 200
    		}
    	},
		변수 환경 컴포넌트(VEC): {},
		this 바인딩 컴포넌트(TBC): {}
	}
	```

7. 초기화 단계로 호출한 함수 파라미터 값을 호출된 함수의 파라미터 이름에 매핑하고 환경 레코드에 작성한다

8. 함수 선언문을 function 오브젝트로 생성한다

9. 함수 표현식과 변수에 초기값을 설정한다

10. 현재 과정까지 실행 상태는 외부에 제공되지 않는다 

    ```json
    실행 콘테스트(EC): {
     	렉시컬 환경 컴포넌트(LEC) = {
         	환경 레코드(ER): {
                bonus: 70,
                point: undefined
            },
    		외부 렉시컬 환경 참조(OLER): {
         		base: 200
     		}
     	},
    	변수 환경 컴포넌트(VEC): {},
    	this 바인딩 컴포넌트(TBC): {}
    }
    ```

11. 실행 단계로 함수 안의 코드를 실행한다

    ```js
    var point = 100
    ```

12. 실행 콘텍스트 안에서 관련된 함수와 변수를 사용할 수 있다 

## 환경 레코드 

#### 구성

- 환경 레코드를 구분하는 이유는 기록 대상에 따라 다르기 때문이다

- 선언적 환경 레코드

  Declarative Environment Record

  - function, qustn, try-catch 문에서 사용

- 오브젝트 환경 레코드

  Object Environment Record

  - 글로벌 함수, 변수, with 문에서 사용
  - 정적이 아니라 동적이다 

- Global Environment

  ```json
  실행 콘텍스트(EC): {
   	글로벌 환경(GE): {
          환경 레코드(ER): {
              오브젝트 환경 레코드: 글로벌 오브젝트 
          }
          외부 렉시컬 환경 참조(OLER): null
      }
  }
  ```

  - 글로벌 오브젝트에서 사용
  - 렉시컬 정정 환경 컴포넌트와 형태 같음

  - 동적으로 함수와 변수 바인딩
    - 함수에서 var 키워드를 사용하지 않고 변수를 선언하면 글로벌 오브젝트에 설정되기 때문이다
    - 이런 이유로 오브젝트 환경 레코드를 사용한다 

  - 외부 렉시컬 참조 값은 null 이다 

## this 바인딩 컴포넌트

- this로 함수를 호출한 오브젝트의 프로퍼티에 접근한다 
- 접근 매커니즘
  1. obj.book() 형태에서
  2. this로 obj를 참조할 수 있도록
  3. this 바인딩 컴포넌트에 obj 참조를 설정한다 

- 설정이 아닌 참조이기 때문에 obj 프로퍼티가 변경되면 동적으로 참조한다

```js
var obj = {
    point: 100
}
obj.getPoint = function(){
    return this.point
}
obj.getPoint()
```

```json
실행 콘테스트(EC): {
 	렉시컬 환경 컴포넌트(LEC) = {
     	환경 레코드(ER): {
            선언적 환경 레코드(DER): {},
			오브젝트 환경 레코드(OER): {}
        },
		외부 렉시컬 환경 참조(OLER): {}
 	},
	변수 환경 컴포넌트(VEC): {},
	this 바인딩 컴포넌트(TBC): {
        point: 100,
        getPoint: function(){}
    }
}
```

1. obj.getPoint() 호출
2. 실행 컨텍스트 생성
3. 3개의 컴포넌트 생성
   - 렉시컬, 변수 환경 컴포넌트, this 바인딩 컴포넌트

4. this 바인딩 컴포넌트에 
   - getPoint()에서 this로 obj 프로퍼티를 사용할 수 있도록 바인딩한다

5. 초기화 단계로 파라미터, 함수 선언문, 변수 선언이 없다 

6. return this.point 실행 

7. this 바인딩 컴포넌트에서 point 검색 

   getPoint() 함수를 호출한 오브젝트가 this 바인딩 컴포넌트에 설정된 상태이다 

8. this 바인딩 컴포넌트에 point 프로퍼티가 있으므로 100을 반환한다
9. **obj.getPoint()에서 obj 프로퍼티가 this 바인딩 컴포넌트에 바인딩되도록 의도적으로 설계해야 한다** 

## 호출 스택

- 실행 콘텍스트의 논리적 구조
- FILO 스택 순서이다 
- 가장 아래에는 글로벌 오브젝트 함수가 위치한다 

## 파라미터 매핑

#### 함수 호출

- 함수가 호출되면 3개의 파라미터 값을 실행 컨텍스트로 넘겨준다
  - 함수를 호출한 오브젝트
  - 함수 코드
  - 호출한 함수의 파라미터 값

- 함수를 호출한 오브젝트를 this 바인딩 컴포넌트에 설정하여 this로 참조
- 함수 코드는 function 오브젝트의 [[Code]]에 설정되어 있다 
- 호출한 함수의 파라미터 값은 호출된 함수의 Argument 오브젝트에 설정되어 있다 

#### 파라미터 값 매핑

- 호출한 함수에서 넘겨 준 파라미타 값을 호출된 함수의 파라미터 작성 순어에 맞추어 값을 매핑하는 것이다

- 엔진 처리 관점

  - 실행 컨텍스트로 넘겨 준 파라미터 값과 funciton 오브젝트의 [[FormalParameters]] 에 작성된 이름에 값을 매핑하고 결과를 선언적 환경 레코드에 설정하는 것이다 

    

## 파라미터 이름에 값 매핑 과정

```js
var obj = {}
obj.getTotal = function(one, two){
    return one + two 
}
obj.getTotal(10, 20, 30)
```

1. getTotal 오브젝트의 [[FormalParameters]] 에서 
   - 호출된 함수의 파라미터 이름을 구한다 
   - 파라미터 이름은 ["one", "two"] 형태이다 
   - [[FormalParameters]]는 function 오브젝트를 생성할 때 설정한다 

2. 파라미터 이름 배열을 하나씩 읽는다
3. 파라미터 값에서 index 번째 값을 구한다 
   - 인덱스 값이 없으면 undefined를 반환한다

4. 이름 배열과 파라미터에서 구한 값을 선언적 환경 레코드에 `{one: 10, two:20}` 형태로 설정하고 같은 이름이 있으면 값이 대체된다 
5. name을 전부 읽을 때까지 3번에서 5번까지 반복한다
